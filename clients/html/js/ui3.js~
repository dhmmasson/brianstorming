$(init)
Array.prototype.last = function () {return this[this.length-1]}
var colors = []
var maxColor = 36
for (var i = 0 ; i < maxColor ; i ++) colors.push ( "hsl(" + ~~(360/maxColor*i) + ",95%, 85%)") ;
colors.__proto__.getOne = function () {
    var i =  ~~(Math.random()*colors.length)  ; 
    var ret = this[i] ; 
    this.splice(i,1) ; 
    return ret ; 
}


{
var uuid_i = 0 ; 
function uuid (str) {
    var a = 0 ; 
    for (var i in str) {
	a*= 181 ; 
	a += str.charCodeAt(i) ; 
    }
    return (a%104729) +"." + (uuid_i++)*( (new Date()).getTime() %104729)  ;
}

}
function Force () {} ;
function MetaData (args) {
    this.color = "red"        ;
    this.timestamp = (new Date()).getTime()       ; 
    this.authors = "Anonymous" ; 
    jQuery.extend(true, this, args);


}
function Node (content, metaData) {
    
    this.metaData = new MetaData (metaData) ; 
    this.content  = content ;
    this.id       = uuid(this.metaData.authors ) ; 



}
function Link (src,dst, rel, metaData) {
    this.source = src ; 
    this.rel    = rel ;
    this.target = dst ;
    this.metaData = new MetaData(metaData)  ; 
}



function initSocket (main) {
    console.log (window.location.host) 
    main.socket = io.connect(window.location.host +':8888/');
    main.socket.on ("active_brainstormings", function (data) {console.log(data)}) 
    main.socket.on('connect', function () {
	main.send   = function (data) {
	    var message =  ((data instanceof Node) ? "node:":"link:") + JSON.stringify(data)
//	    console.log(message) 
	    main.socket.emit("message",message) ;
			     
	    
	}
	main.socket.on('message', function (data){
	    console.log(data)
	    receive(data)
	    
	} );
    });
}




var nodes_ = [],
data3 =   new Node("Brainstorming", {color:"white", 
					timestamp : (new Date()).getTime(), 
					authors:"initial", 
					"class": "initial"}
		     )






function initSvgAndForceLayout (width, height) {
    this.fill = d3.scale.category20();
    this.force = d3.layout.force()
	.size([this.width, this.height])
	.nodes(nodes_) 
	.gravity(0.01)
	.linkDistance(20)
	.linkStrength(0.7)
	.charge(-30)
	.on("tick", createTick(this) );
    this.vis.svg = d3.select("body")
//	.on("keydown", createKeyDown(this) ) 
	.append("svg")
	.attr("width", this.width)
	.attr("height", this.height)
	.on("mousemove", createMouseMove(this)   )
	.on("mousedown", createMouseDown(this) )

    this.vis.cursor = this.vis.svg.append("circle")
	.attr("r", 30)
	.attr("transform", "translate(-100,-100)")
	.attr("class", "cursor");



    return this ; 
}




function transcribeNodeToLInk (nodes,links) {
    var tmpNode = {} ;
    for(var i = 0; i < nodes.length; i++) {
	tmpNode[nodes[i].session +"." +nodes[i].id] = i+1 ; 
	var ll = nodes[i].versions.last().links ; 
	for (var j in ll) {
	    var src = ll[j].src.split(".").slice(0,2).join(".")
	    var dst = ll[j].dst.split(".").slice(0,2).join(".")
	    if (tmpNode[src] && tmpNode[dst]) {
		//pushback unused colors 
		colors.push( nodes[tmpNode[src]-1].versions.last().metaData.color)
		nodes[tmpNode[dst]-1].versions.last().metaData.color=  nodes[tmpNode[src]-1].versions.last().metaData.color;
		links.push({
		    color  : nodes[tmpNode[src]-1].versions.last().metaData.color,
		    source : tmpNode[src]-1,
		    target : tmpNode[dst]-1,
		    weight : 1
		});
	    }
	}
    }
}

function refreshElements () {
    this.nodes = this.force.nodes() ; 
    this.links = this.force.links() ;

    this.vis.refreshElements () ; 

    var createFilter = function (id) { 
	return function (d) {
	    return d.id == id
	}}


    if (this.currentLabel)
	this.vis.currentLabel = this.vis.nodes.filter(createFilter(this.currentLabel.id)) ; 
    if (this.previousLabel) {

	this.vis.previousLabel = this.vis.nodes.filter(createFilter(this.previousLabel.id)) ; 
    } 
    return this ; 

}
function refreshVisElements () {

    this.nodes       = this.svg.selectAll (".node") ;
    this.links       = this.svg.selectAll (".link")  ;
    this.labels      = this.nodes.selectAll(".label") ;
    this.backgrounds = this.nodes.selectAll(".background") ;
    return this ; 
}




function tick(main) {
    var q = d3.geom.quadtree(main.nodes),
    i = 0,
    n = main.nodes.length;
	while (++i < n) {
    	    q.visit(collide(main.nodes[i]));
	}
    main.vis.updateNode()
	.updateLink() ; 
}


function resize() {
    main.width = window.innerWidth, main.height = window.innerHeight;
    main.vis.svg.attr("width", main.width).attr("height", main.height);
    if (main.nodes) {
	var dx =  main.width/2  - main.nodes[0].x,
        dy =  main.height/2 - main.nodes[0].y;
	for (var i in main.nodes) {
	    main.nodes[i].x += dx
	    main.nodes[i].y +=dy ;
	} 
	main.nodes[0].px += dx
	main.nodes[0].py += dy
    }
    main.force.size([main.width, main.height]).resume();


}
//Node---------------------------------------------------------------
function nodeOnEnter () {
    var enteringNode = this.nodes.enter().insert("svg:g")
	.attr("class", "node") ;
    enteringNode.append("rect")
	.attr("class", "background") ;
    enteringNode.append("text")
	.attr("class", "label")
    return this ; 
}
function nodeOnUpdate() {

    this.refreshElements () ; 
    this.nodes
    	.attr("class", function(d){ return "node"})

	.attr("transform",  function(d) { 
	    return "translate(" +( d.x - d.width/2) +", " +( d.y + d.height/3)+ ")"
	})
	.on("mousedown", createMouseDown(main) );
    
 
    if (this.currentLabel)
	this.currentLabel
	.attr("class", "node current")
    if (this.previousLabel)
	this.previousLabel
	.attr("class", "node previous")
	      
    this.labels
	.text(function(d, i) { return d.content ; }) 
	.style("font-size", 12)
	.each(function (d) {
	    var bbox = this.getBBox() ; 
	    d.width = bbox.width + 10 ,
	    d.height = bbox.height || 10; 
	})
    this.backgrounds
	.attr("width", function (d) { return d.width })
	.attr("height", function (d) { return d.height })
        .attr("rx",5)
	.attr("ry",5)
	.attr("y",function(d){
	    return -d.height + 3
	})
	.attr("x",function(d){
	    return -5
	})
	.style("fill", function(d){
	    return d.metaData.color})
    return this ; 
}
function nodeOnExit() {

}




//Link visualisation ---------------------------------------------------
function linkOnEnter () {

    this.links.enter().insert("line", ".node")
	.attr("class", "link")
	.attr ("fill", function (d) {return d.metaData.color})
    return this ; 
}
function linkOnUpdate () {
    this.links.attr("x1", function(d) { return d.source.x; })
	.attr("y1", function(d) { return d.source.y; })
   	.attr("x2", function(d) { return d.target.x; })
	.attr("y2", function(d) { return d.target.y; });
    return this ; 
}
function linkOnExit () {
  

    return this 
}

    


function restart() {

    this.nodes[0].fixed= true ; 
    this.refreshElements () ; 
    this.vis.nodes = this.vis.nodes.data(this.nodes, function (d){return d.id});
    this.vis.links = this.vis.links.data(this.links);   

    this.vis.links.exit().remove() ;
    this.vis.nodes.exit().remove() ;

    this.vis
	.createNode()
	.createLink()
	.updateNode() 
        .updateLink() 
    this.vis
        .exitLink()
	.exitNode()
 
    this.vis.nodes.call(this.force.drag);
    this.force.start();
    return this ; 
}







function collide(node) {
    var rx = node.width + 16, ry = node.height + 4, 
    nx1 = node.x - rx,
    nx2 = node.x + rx,
    ny1 = node.y - ry,
    ny2 = node.y + ry;
    return function(quad, x1, y1, x2, y2) {
	if (quad.point && (quad.point !== node)) {
	    var x =(node.x - quad.point.x),
	    y = (node.y - quad.point.y),
	    ax =  Math.abs(x),
	    ay =  Math.abs(y),
	    rx = (node.width + quad.point.width + 5) /2,
	    ry = (node.height + quad.point.height + 5 )/2 ;
	    if (ax < rx && ay < ry) {
		if ( rx- ax < ry-ay) {
		    ax = (ax - rx) / ax * .3;
		    node.x -= x *= ax;
		    quad.point.x += x;
		} else {
		    ay = (ay - ry) / ay * .3;
		    node.y -= y *= ay;
		    quad.point.y += y;
		}

	    }
	}
	return x1 > nx2
	    || x2 < nx1
	    || y1 > ny2
	    || y2 < ny1;
    };
}

function Vis () {} ; 
function Main (arg) {
     for (var i in arg ){
	 if (typeof arg[i] == "function") continue
	 this[i]=arg[i] ; 
     }
} ; 

function init () {
    //default settings--------------------------------------
    var textInput = document.querySelector('input');
    
    new FastClick(document.body);
    document.body.addEventListener('click', function(e) {
	textInput.focus();
	mousedown.call(e.target, getMain())
    }, false) ;

    
    function setFocus()
    {
	document.getElementById("tapetita").focus();
	setTimeout(setFocus, 300) ;
    }
    setFocus() ; 
 


    Vis.prototype.createNode = nodeOnEnter ;
    Vis.prototype.updateNode = nodeOnUpdate ;
    Vis.prototype.exitNode = nodeOnExit ;
    Vis.prototype.createLink = linkOnEnter ;
    Vis.prototype.updateLink = linkOnUpdate ;
    Vis.prototype.exitLink = linkOnExit ;
    Vis.prototype.refreshElements = refreshVisElements ; 

    Main.prototype.refreshElements = refreshElements ; 
    Main.prototype.restart         = restart ; 


    var vis = new Vis(),
        main = new Main ({  width:960,height:500, vis:vis}) ;
    initSocket(main) ;
    function getMain(){return main}
    data3.fixed = true ; 
    data3.x = main.width/2 ;
    data3.y = main.height/2 ; 

    nodes_ = [data3] ; 
    d3.select(window).on("resize", resize);
    document.body.addEventListener("touchend", createMouseDown(main))
    //export to window
    window.main=main ; 
    //--Init Svg and force layout----------------------------
    initSvgAndForceLayout.call(main) ;
    resize() ;
    






    main.refreshElements();

  
    
    
    main.previousLabel=main.nodes[0] ; 
  
    main.refreshElements() ;

    //Create Cursor -----------------------------------------

    main.restart();


  

    $("#tapetita").keyup(function (e) {
	
	if(e.which == 13) {
	   EnterKeyDown.call(this, e) ;
       }
	if (main.currentLabel == undefined) {
	    newNode() ;
	} else if ((e.which > 46 || e.which == 8) && e.which != 91 ) {
	    main.currentLabel.content = this.value ; 
	    main.restart() ; 
	}
	
    })
  

newNode;
   





}

function receive (data) {
    data =  data.split("\n")
    for (var i in data) {
	if (typeof data[i]  == "function" ) continue 
	var e = data[i];
	if (e.substring(0,5) == "link:") {
	    var l = JSON.parse(e.substring(5)) ;
	    console.log("link " + l.source + "->" + l.target) ;
	    var source = false, target = false ;
	    for (var i in main.nodes) {
		if (main.nodes[i].id == l.source) source = main.nodes[i]
		if (main.nodes[i].id == l.target) target = main.nodes[i]
	    }
	    if (source && target) {
		l.source = source ; 
		l.target = target ; 
		main.links.push (l) 
	    } else {
		
		console.warn("Can't link new node." +  (target) ?"\nSource : " + l.source :  "\nTarget : " + l.target ) ;
		function aux (data) { return function () {receive (data)} } ;
		setTimeout(aux(e),2000) ; 
	    }

	}
	else if (e.substring(0,5) == "node:") {
	    main.nodes.push (JSON.parse(e.substring(5)) )
	    console.log("node " + main.nodes.last().id)
	}
    }
    main.restart() ; 
}
function EnterKeyDown (e) {
    if (this.value == "") {
	for (var i in main.nodes) {
	    if (main.nodes[i] == main.currentLabel) {
		main.nodes.splice(i,1)
		break ; 
	    }
	}
	for (var i in main.links) {
	    if (main.links[i].source == main.currentLabel) {
		main.links.splice(i,1) ; 
	    }
	}
	main.currentLabel = main.previousLabel ; 
    } else {
	main.send ( main.currentLabel )
	var l = JSON.parse(JSON.stringify(main.links.last())) ;
	l.source = l.source.id ; 
	l.target = l.target.id ;
	main.send ( l ) ;
    }

    this.value = ""
    if(main.previousLabel)
	main.previousLabel.class = undefined ; 
    if(main.currentLabel) {
	main.currentLabel.class = undefined ; 
	main.currentLabel.fixed=false ;
	main.previousLabel = main.currentLabel ; 
    }
    main.currentLabel = undefined 
    main.lastEnterShifted = e.shiftKey ;
    if (e.shiftKey==false && main.previousLabel) {
	main.previousLabel.class = "previous" ; 
    } else {
	main.previousLabel =main.nodes[0];
    }

}
function newNode () {
    var pos = {x :~~main.vis.cursor.attr("x"), y:~~main.vis.cursor.attr("y")} ;
    var color = 0 ;
    if (main.lastEnterShifted==false && main.previousLabel) {
	var dx = (main.previousLabel.x  - main.width/2),
	dy = (main.previousLabel.y  - main.height/2),
	norm = Math.sqrt(dx*dx+dy*dy) ;
	    
	pos.x = main.previousLabel.x + 20* dx/norm ;
	pos.y = main.previousLabel.y+ 20* dy/norm ;
	if (main.previousLabel.metaData.color  != "white")
	    color = main.previousLabel.metaData.color 
	
    }
    if (!color) color = colors.getOne() ; 
    node = new Node (this.value || "type your message", {authors: "Dimitri", color:d3.hsl(color).darker(0.3).toString()})
    jQuery.extend(true, node, {x: pos.x, y: pos.y, fixed: false} );
    main.nodes.push(node);
    
    
    var link = new Link (node,main.previousLabel, "next", {color:d3.hsl(color).darker(0.3).toString(), authors: "Dimitri"}) 
    main.links.push(link) ; 
    
    main.currentLabel = node ; 
    main.restart();
}

function mousemove(cursor) {
    cursor.attr("x", d3.mouse(this)[0]) 
	.attr("y", d3.mouse(this)[1]) 
	.attr("transform", "translate(" + d3.mouse(this) + ")");
}

function mousedown(main) {
    var     node =  d3.select(this).datum() ;
    if (node && node != main.currentLabel && node != main.previousLabel) {
	
	EnterKeyDown.call ($("#tapetita")[0], new jQuery.Event("keyup", { keyCode: 13, which:13, shiftKey:false })) 
	main.previousLabel = node ; 
	newNode() ; 
    }
    
}


function createMouseDown (main) {
    return function () {
	mousedown.call(this, main)
    }
}
function createMouseMove (main) {
    return function () {
	mousemove.call(this, main.vis.cursor) ;
    }
}


function createKeyDown (main) {
    var keyDown=function (main) {
	var e = d3.event ;
	evt = e || window.event;
	var charCode = evt.which || evt.keyCode;
	var charStr = String.fromCharCode(charCode);
	

    



    }
    return function (e) {
	keyDown.call(this, main)
    }
}

function createTick (main) { return  function () {tick(main) }}
